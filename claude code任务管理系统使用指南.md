# Claude Code 任务管理系统使用指南

## 概述

想象一下：你雇了一个 AI 助手帮你干活，但有个严重问题——它"记性不好"。

**通俗类比：**
- **问题** = 就像雇了个短期记忆只有 7 秒的助理，你说的话它转头就忘
- **后果** = 每次它"失忆"，你得重新告诉它要做什么
- **解决方案** = 给它一个"记事本"，把所有任务写在上面，随时可以查看

---

# 第一部分：破解"智能体失忆症"

## 1.1 什么是"智能体失忆症"

**通俗类比：** 就像你正在和同事讨论工作：
- 你："先做 A，再做 B，最后做 C"
- 同事："好的，没问题"
- （5 分钟后，同事突然懵了）
- 同事："等等，你刚才说让我做什么来着？"

**在 Claude Code 中：**
- 对话太长，AI 记不住之前的指令
- 电脑崩溃，对话中断，AI "忘记"了所有任务
- 你用了 `/clear` 命令清空上下文，任务列表也没了

**旧系统的问题：**
```
任务列表存在内存里
  ↓
一旦崩溃或 /clear
  ↓
任务列表全部消失 😱
  ↓
你得手动记录剩余任务
  ↓
重新告诉 AI 要做什么
```

## 1.2 新系统的解决方案

**核心思想：** 把任务从"脑子"（内存）搬到"记事本"（文件）上。

**通俗类比：**
- **旧系统** = 你让助理记在脑子里（容易忘）
- **新系统** = 你让助理写在记事本上（不会忘）

**好处：**
```
任务列表存在文件里 (.claude/tasks/)
  ↓
即使崩溃、重启、/clear
  ↓
任务列表依然存在 ✅
  ↓
AI 随时可以打开记事本查看
  ↓
继续工作，不用重新开始
```

---

# 第二部分：核心架构 - 分布式任务编排

## 2.1 本地存储 = 永久记事本

**是什么：** 所有任务都保存在项目的 `.claude/tasks` 文件夹里。

**通俗类比：** 就像项目经理的白板：
- 写在白板上（文件里）
- 每个人都能看到
- 即使所有人下班回家（会话结束）
- 第二天来上班，白板上的字还在

**文件位置：**
```
你的项目/
├── src/
├── tests/
└── .claude/
    └── tasks/
        └── [任务数据文件]
```

**好处：**
- ✅ 崩溃不丢失
- ✅ 重启可恢复
- ✅ 多人共享（通过 Git 同步）
- ✅ 跨设备访问

## 2.2 任务依赖与"波次"执行

### 什么是任务依赖

**通俗类比：** 就像做菜的步骤：
```
步骤 1：买菜
    │
    ↓（依赖：必须先买好菜）
步骤 2：切菜
    │
    ↓（依赖：必须先切好菜）
步骤 3：炒菜
    │
    ↓（依赖：必须先炒好菜）
步骤 4：装盘
```

**在软件项目中：**
```
任务 1：设计数据库表结构
    │
    ↓（被阻断：Blockers）
任务 2：写后端 API
    │
    ↓（被阻断：Blockers）
任务 3：写前端界面
    │
    ↓（被阻断：Blockers）
任务 4：测试
```

### 什么是"波次"（Waves）

**通俗类比：** 就像运动会的比赛项目：
- **第一波（Wave 1）** = 所有可以同时开始的项目（比如 100 米跑、跳远、铅球）
- **第二波（Wave 2）** = 等第一波结束后才能开始的项目（比如接力赛，需要先选出第一波的优胜者）

**在任务管理中：**
```
Wave 1（可以同时做的任务）：
├── 任务 A：配置开发环境（无依赖）
├── 任务 B：设计数据库结构（无依赖）
└── 任务 C：编写项目文档（无依赖）

Wave 2（等 Wave 1 完成后才能做的任务）：
├── 任务 D：写后端 API（依赖任务 B）
└── 任务 E：写前端界面（依赖任务 B）

Wave 3（等 Wave 2 完成后才能做的任务）：
└── 任务 F：集成测试（依赖任务 D 和 E）
```

### 系统如何自动分配波次

**通俗类比：** 就像聪明的婚礼策划师：
- 看到任务清单
- 自动分析："这些可以同时做，那些必须等前面的做完"
- 安排最优顺序

**系统做的事：**
```
任务列表：
├── 任务 A（无依赖）
├── 任务 B（依赖 A）
├── 任务 C（无依赖）
├── 任务 D（依赖 B）
└── 任务 E（依赖 A）

系统自动分析：
Wave 1: A, C（可以同时做）
Wave 2: B, E（等 A 完成后）
Wave 3: D（等 B 完成后）
```

## 2.3 上下文隔离 = 独立办公室

### 问题场景

**不隔离的后果：**
```
主会话（拥挤的会议室）：
├── 任务 A 的代码（100 行）
├── 任务 B 的代码（200 行）
├── 任务 C 的代码（300 行）
└── 任务 D 的代码（400 行）

问题：
- 上下文窗口占用 56%（满了）
- 互相干扰，容易混乱
- 改任务 A 的代码，可能影响任务 B
```

### 解决方案：子智能体隔离

**通俗类比：** 给每个人一个独立办公室：
- 任务 A 的开发者 → 办公室 1
- 任务 B 的开发者 → 办公室 2
- 任务 C 的开发者 → 办公室 3
- 任务 D 的开发者 → 办公室 4

**好处：**
```
独立办公室（子智能体）：
├── 办公室 1：只处理任务 A（干净）
├── 办公室 2：只处理任务 B（干净）
├── 办公室 3：只处理任务 C（干净）
└── 办公室 4：只处理任务 D（干净）

上下文占用：18%（省了 2/3！）
```

**数据对比：**
| 方式 | 上下文占用 | 合并冲突风险 |
|------|-----------|-------------|
| 全部挤在主会话 | 56% | 高 |
| 子智能体隔离 | 18% | 低 |

### 重要提醒

**通俗类比：** 虽然每个人有独立办公室，但：
- 每个人完成工作后，还是要给老板（主会话）汇报
- 老板会收到所有汇报（上下文还是会增长）
- 只是增长得慢一些

**技术原理：**
- 子智能体有独立上下文 ✅
- 但主会话会汇总所有子智能体的输出 ⚠️
- 主会话的上下文仍会缓慢增长，但比不隔离慢得多 ✅

---

# 第三部分：四大核心工具

## 工具总览

| 工具 | 功能 | 生活类比 |
|------|------|----------|
| **TaskCreate** | 创建新任务 | 项目经理在白板上添加新任务 |
| **TaskGet** | 获取任务详情 | 查看白板上的任务说明 |
| **TaskUpdate** | 更新任务状态 | 标记任务完成或更新进度 |
| **TaskList** | 查看所有任务 | 浏览整个任务清单 |

## 3.1 TaskCreate - 创建任务

**是什么：** AI 可以自主创建新任务。

**通俗类比：** 就像工人发现问题时，可以自己在白板上加任务：
```
工人 A："嘿，我发现个 Bug！"
  ↓
工人在白板上写下：
"任务 X：修复登录页面的 Bug"
  ↓
其他工人看到后可以去处理
```

**实际使用：**
```
子智能体在执行任务时：
"我发现数据库查询有个性能问题"
  ↓
调用 TaskCreate
  ↓
创建新任务："优化数据库索引"
  ↓
任务进入队列，等待执行
```

**专家场景：**
- 子智能体发现新 Bug
- 自动创建修复任务
- 不需要人工干预

## 3.2 TaskGet - 获取任务详情

**是什么：** 查看某个任务的完整信息。

**通俗类比：** 就像从白板上撕下某张任务便签，仔细看上面的要求。

**实际使用：**
```
校验者（Checker）角色：
"我要验证任务 5 是否完成了"
  ↓
调用 TaskGet(5)
  ↓
获取任务 5 的原始需求
  ↓
对比实际完成情况
  ↓
判断是否真的完成
```

**专家场景：**
- 质检员验证任务质量
- 获取原始需求作为"标准答案"
- 对比实际产出

## 3.3 TaskUpdate - 更新任务状态

**是什么：** 更新任务的进度、状态或附加信息。

**通俗类比：** 就像在任务便签上写："进行中"、"已完成"或"遇到问题"。

**实际使用：**
```
子智能体 A 完成了一半：
"我写完了 API，但还没测试"
  ↓
调用 TaskUpdate(任务3)
  ↓
更新状态："50% 完成，API 已实现，待测试"
  ↓
其他智能体可以看到最新进度
```

**专家场景：**
- 传递关键变量给其他智能体
- 标记阶段性成果
- 记录遇到的问题

## 3.4 TaskList - 查看所有任务

**是什么：** 获取整个任务清单和状态视图。

**通俗类比：** 就像站在白板前，浏览所有任务和它们的状态。

**实际使用：**
```
启动新的会话：
"我现在要做什么？"
  ↓
调用 TaskList()
  ↓
获取所有任务列表：
├── 任务 1：✅ 已完成
├── 任务 2：🔄 进行中
├── 任务 3：⏸️ 被阻断（等待任务 2）
└── 任务 4：⏳ 待开始
  ↓
知道该做什么，不会重复劳动
```

**专家场景：**
- 跨会话同步
- 防止多个实例重复做同一任务
- 全局视图

---

# 第四部分：多会话协同 - 多人协作

## 4.1 实时广播机制

**旧方式：轮询（Polling）**

**通俗类比：** 就像你每隔 30 秒问一次："白板有更新吗？"
- 浪费时间
- 可能有 30 秒的延迟
- 两个人可能同时抢同一个任务

**新方式：实时广播**

**通俗类比：** 就像每个人都戴着耳机：
- 白板一有更新，立刻通知所有人
- 零延迟
- 不会两个人抢同一个任务

**技术对比：**
| 方式 | 延迟 | 风险 |
|------|------|------|
| **轮询** | 30 秒+ | 可能重复执行 |
| **广播** | 实时 | 安全可靠 |

## 4.2 Checker 模式 - 自动质检体系

**是什么：** 启动一个专门的"监控会话"，自动检查已完成任务的质量。

**通俗类比：** 就像工厂的质检员：
- 工人完成任务 → 放到传送带上
- 质检员实时检查
- 发现问题 → 退回去返工
- 没问题 → 打包出厂

### Checker 模式工作流

```
┌─────────────────────────────────────────┐
│  启动两个会话（共享同一个任务列表 ID）   │
│                                         │
│  ┌──────────────┐    ┌──────────────┐  │
│  │ 工作会话     │    │ 监控会话     │  │
│  │ (Worker)     │    │ (Checker)    │  │
│  └──────────────┘    └──────────────┘  │
│         │                    │          │
│         │                    │          │
└─────────┼────────────────────┼──────────┘
          │                    │
          ▼                    │
    [执行任务]                │
         │                    │
         ▼                    │
   [标记为完成] ──────────────┼──┐
          │                    │  │
          │                    ▼  ▼
          │            [每 5 秒检查]
          │                    │
          │            TaskList()
          │                    │
          │            发现新完成的任务
          │                    │
          │                    ▼
          │            TaskGet(任务ID)
          │                    │
          │            获取原始需求
          │                    │
          │                    ▼
          │            [验证任务]
          │                    │
          │         ┌──────────┴──────────┐
          │         │                     │
          ▼         ▼                     ▼
      [通过]    [发现缺陷]          [需要验证]
          │         │                     │
          │         ▼                     ▼
          │    TaskCreate(        派子智能体验证
          │      "修复缺陷")          │
          │         │             ┌─────┴─────┐
          │         ▼             ▼           ▼
          └──► 重新加入队列    通过      不通过
                                    │         │
                                    └────┬────┘
                                         ▼
                                   TaskCreate(
                                     "修复缺陷")
```

### 交叉模型验证（Cross-model Validation）

**是什么：** 用不同的 AI 模型互相验证。

**通俗类比：** 就像论文审稿：
- 作者用 Claude 写完
- 编辑用 Gemini 再审一遍
- 两个模型都通过 → 更可靠

**高级用法：**
```
工作会话（Claude Opus）执行任务
  ↓
监控会话调用 Gemini CLI
  ↓
用不同模型验证结果
  ↓
如果发现缺陷 → 创建修复任务
```

**好处：**
- 降低单一模型的盲点
- 提高代码质量
- 发现隐藏的问题

---

# 第五部分：配置指南

## 5.1 问题：默认 ID 随会话变化

**默认行为：**
```
会话 1：task-list-id = abc123
  ↓
/clear
  ↓
会话 2：task-list-id = xyz789（新的 ID！）
  ↓
任务列表丢失关联 😱
```

**通俗类比：** 就像你每次换办公室，白板就换了一块，之前写的任务都看不见了。

## 5.2 解决方案：手动指定 ID

### 方法 1：环境变量

```bash
# 在终端设置
export CLAUDE_CODE_TASK_LIST_ID=my_project_v1
claude
```

**通俗类比：** 给白板贴个固定的标签："项目 X 的白板"，无论换哪个办公室，都找这块白板。

### 方法 2：settings.json（推荐）

在项目的 `.claude/settings.json` 中配置：

```json
{
  "taskListId": "my_project_v1"
}
```

**好处：**
- 所有开发者共享同一个任务列表
- Git 同步后，团队能看到彼此的任务
- 真正的协作

### 生命周期管理

**自动清理：**
```
所有任务都标记为完成
  ↓
系统自动清理 .claude/tasks/
  ↓
保持项目目录整洁
```

**通俗类比：** 就像项目结束后，保洁阿姨自动把白板擦干净。

---

# 第六部分：最佳实践

## 6.1 显式指令触发

**问题：** 系统并不总是自动启用子智能体模式。

**解决方案：** 在 Prompt 中明确要求。

**好的 Prompt：**
```
"请使用独立的子智能体执行列表中的各项任务"
(Execute each task in its own sub-agent)
```

**通俗类比：** 就像你对项目经理说："给每个任务分配一个独立的人，不要都在一个人脑子里"

## 6.2 异常捕获 - 教育子智能体

**问题：** 子智能体遇到 Bug 时，可能强行合并错误的代码。

**解决方案：** 教会它使用 TaskCreate 记录问题。

**训练 Prompt：**
```
"如果你在执行任务时遇到未知的 Bug，
不要强行合并代码。
请使用 TaskCreate 创建一个修复任务，
然后继续处理其他任务。"
```

**通俗类比：** 就像教工人："遇到问题不要硬闯，先写个便签，让专门的人来处理"

## 6.3 工具选择

**内置系统 vs 原生 Beads 库**

| 特性 | 内置系统 | 原生 Beads |
|------|---------|-----------|
| **易用性** | 高（无缝集成） | 中（需要配置） |
| **自定义** | 中等 | 高（完全控制） |
| **适用场景** | 大多数项目 | 特殊需求 |

**建议：**
- 大多数项目 → 用内置系统（简单、够用）
- 特殊需求（如特殊 JSON 结构、外部 API）→ 用原生 Beads 库

## 6.4 监控开销平衡

**问题：** Checker 模式频繁检查会消耗 API 配额。

**解决方案：** 根据项目规模调整检查频率。

**建议：**
```
小型项目（< 10 个任务）：
→ 每 5 秒检查一次

中型项目（10-50 个任务）：
→ 每 10-15 秒检查一次

大型项目（> 50 个任务）：
→ 每 30 秒检查一次
```

**通俗类比：** 就像工厂质检：
- 小作坊 → 每个产品都仔细检查
- 大工厂 → 抽样检查（太贵了查不过来）

---

# 总结：5 条核心原则

## 1. 任务要持久化

**类比：** 写在记事本上，而不是记在脑子里

**实践：**
- 任务自动保存到 `.claude/tasks/`
- 崩溃、重启都能恢复
- 多人共享任务列表

## 2. 依赖要清晰

**类比：** 做菜要先买菜，才能切菜、炒菜

**实践：**
- 系统自动分析任务依赖
- 按波次（Waves）执行
- 被阻断的任务等待依赖完成

## 3. 隔离要彻底

**类比：** 每个人一个独立办公室，避免干扰

**实践：**
- 用子智能体隔离任务
- 上下文占用从 56% 降到 18%
- 防止合并冲突

## 4. 验证要及时

**类比：** 工厂质检员实时检查产品质量

**实践：**
- 启用 Checker 模式
- 发现问题立刻创建修复任务
- 可选：交叉模型验证

## 5. ID 要固定

**类比：** 给白板贴个固定标签，别每次都换

**实践：**
- 在 settings.json 中配置 taskListId
- 团队共享同一个任务列表
- Git 同步协作

---

# 最终类比：项目管理 2.0

**把任务管理系统想象成升级版的项目管理工具：**

| 概念 | 传统项目管理 | Claude Code 任务管理 |
|------|-------------|---------------------|
| **任务存储** | 白板/Excel（手动） | 自动持久化到文件 |
| **依赖管理** | 手动画箭头 | 自动分析波次 |
| **执行隔离** | 所有人挤在一个会议室 | 每个任务独立办公室 |
| **状态同步** | 开会口头汇报 | 实时广播 |
| **质量检查** | 事后验收 | 实时质检（Checker） |
| **崩溃恢复** | 从头开始 | 自动恢复 |

**最终目标：**

> 一个永不遗忘、自动分配、实时协同的 AI 项目管理系统。

---

## 快速入门

### 1. 启用任务管理

```bash
# 在项目根目录
cd your-project
claude

# Claude 会自动使用任务管理系统
```

### 2. 配置固定 ID

```json
// .claude/settings.json
{
  "taskListId": "my_project_v1"
}
```

### 3. 创建任务

```
你：帮我开发一个用户认证系统

Claude：
[自动创建任务]
- 任务 1：设计数据库
- 任务 2：编写后端 API
- 任务 3：编写前端界面
- 任务 4：集成测试
```

### 4. 监控进度

```
你：现在任务列表是什么？

Claude：
[调用 TaskList]
- 任务 1：✅ 已完成
- 任务 2：🔄 进行中
- 任务 3：⏸️ 等待任务 2
- 任务 4：⏳ 待开始
```

---

## 参考资源

- Claude Code 官方文档
- Beads 开源库
- Ralph Wiggum 模式
- Agent Teams 协作机制

---

*来源：Claude Code 任务管理系统技术文档*
*本文由文科生友好的比喻改编*
*配合《Claude Code 深度技巧》、《Claude Code 进阶技巧》、《Agent Team 技巧》一起阅读效果更佳*
