# Agent Teams 技巧 - 让 AI 团队协同工作

## 概述

想象一下：以前你只有一个 AI 助手（就像雇了一个"万能工人"）。现在你可以有一整个 AI 团队（就像开了一家公司，有项目经理、前端工程师、后端工程师、测试工程师等）。

**通俗类比：**
- **单一 AI** = 雇一个什么都干的"万能工人"
- **Agent Teams** = 组建一个专业团队，各司其职

---

# 第一部分：Agent Teams 是什么？

## 核心概念

**是什么：** 多个 AI 智能体协同工作，像一个真正的工程团队。

**通俗类比：** 想象你在盖房子：
- **单一 AI** = 一个工人，既会砌墙、又会布线、还会粉刷（但什么都做不精）
- **Agent Teams** = 一个团队：
  - 项目经理（指挥全局）
  - 泥瓦工（专门砌墙）
  - 电工（专门布线）
  - 油漆工（专门粉刷）
  - 质检员（检查质量）

**优势：**
- 效率更高（每个人做自己擅长的事）
- 质量更好（专业的人做专业的事）
- 规模更大（可以同时做多件事）

# 第二部分：三大核心组件

## 1. 共享任务列表（Shared Task List）

**是什么：** 整个团队共用的"任务白板"。

**通俗类比：** 就像团队办公室中间的白板：
- 写着所有要做的任务
- 每个人都能看到
- 完成一项就划掉一项
- 实时更新，所有人知道进度

**好处：**
- 透明化（每个人都知道要做什么）
- 避免重复（两个人不会做同一件事）
- 进度可见（随时知道项目到哪了）

## 2. 阻断器机制（Blockers）

**是什么：** 任务之间的依赖关系管理。

**通俗类比：** 就像做菜的步骤：
- 切菜 → 炒菜 → 装盘

**阻断关系：**
- 如果还没切好菜，就不能开始炒菜（被阻断）
- 如果还没炒好菜，就不能开始装盘（被阻断）

**在软件开发中：**
```
任务 A：设计数据库表结构
    │
    ↓ 阻断
任务 B：写后端 API（需要先有数据库表）
    │
    ↓ 阻断
任务 C：写前端界面（需要先有 API）
```

**好处：**
- 智能体不会做无用功（不会在依赖没完成时就开始）
- 资源高效利用（只有准备好的任务才会被认领）
- 减少返工（按正确顺序做事）

## 3. 收件箱系统（Inbox/Message System）

**是什么：** 智能体之间互相发消息的"内部通讯系统"。

**通俗类比：** 就像公司的内部聊天软件（比如钉钉、企业微信）：
- 前端工程师："后端大哥，这个 API 接口什么格式？"
- 后端工程师："返回 JSON，字段是 `{id, name, email}`"
- 前端工程师："收到，谢了！"

**为什么重要：**

没有收件箱系统：
```
前端智能体（自己瞎猜）：
"我猜 API 返回的应该是 XML 格式"
  ↓
写了一堆代码
  ↓
后端智能体（写完后才发现）：
"不对，我返回的是 JSON 啊"
  ↓
前端代码白写了，要重写
```

有收件箱系统：
```
前端智能体（主动问）：
"后端大哥，API 什么格式？"
  ↓
后端智能体（立刻回）：
"JSON，{id, name, email}"
  ↓
前端智能体（按照正确格式写）：
"好的，我按这个写"
  ↓
一次做对，不返工
```

---

# 第三部分：团队协作流程

## 完整工作流

```
[你提出需求]
    │
    ▼
┌─────────────────┐
│ 主智能体 (Leader) │
│ (项目经理)       │
└────────┬────────┘
         │
         ▼
   1. 拆解任务
   （把大任务拆成小任务）
         │
         ▼
   2. 组建团队
   （根据任务生成团队成员）
         │
         ▼
   [任务列表]
   （共享白板）
         │
         ├─→ 任务 1：设计数据库
         ├─→ 任务 2：写后端 API
         └─→ 任务 3：写前端界面
         │
         ▼
┌─────────────────────────────────┐
│  团队成员认领任务                 │
│                                 │
│  ┌──────────┐  ┌──────────┐   │
│  │后端智能体 │  │前端智能体 │   │
│  └──────────┘  └──────────┘   │
│       │             │          │
│       ▼             ▼          │
│   "我认领任务2"  "我认领任务3"  │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  执行中通过收件箱实时沟通         │
│                                 │
│  前端："API 接口什么格式？"      │
│  后端："JSON，{id, name}"       │
│  前端："收到"                   │
└─────────────────────────────────┘
         │
         ▼
   [任务完成]
         │
         ▼
┌─────────────────────────────────┐
│  结果回传给 Leader 审计          │
│                                 │
│  Leader："前端和后端的接口对不上"│
│  前端："让我重新检查..."        │
│  后端："我的错了，应该是..."    │
└─────────────────────────────────┘
         │
         ▼
   [修复问题]
         │
         ▼
   [全部完成]
         │
         ▼
┌─────────────────────────────────┐
│  团队成员解散或进入待命状态       │
└─────────────────────────────────┘
```

## 关键优势

### 1. 解决"假设冲突"问题

**没有 Agent Teams：**
```
前端智能体（在自己的分支工作）：
"我猜后端会叫 userLogin()，我就调用这个"
  ↓
后端智能体（在自己的分支工作）：
"我觉得叫 login() 更好"
  ↓
合并代码时：冲突！两个都对不上
```

**有 Agent Teams：**
```
前端智能体（通过收件箱问）：
"后端大哥，登录接口叫什么名字？"
  ↓
后端智能体（立刻回）：
"login()"
  ↓
前端智能体：
"好的，我就用 login()"
  ↓
合并代码时：完美对接，没有冲突
```

### 2. 实时质量控制

**通俗类比：** 就像餐厅有个"试菜员"：
- 厨师每道菜做好，先给试菜员尝
- 发现问题立刻调整
- 不会等端到客人才发现太难吃

**在 Agent Teams 中：**
```
┌─────────────────────────────────┐
│  团队角色：魔鬼代言人            │
│  （专门挑刺的质检员）            │
└─────────────────────────────────┘
         │
         ▼
前端智能体写完代码
  ↓
魔鬼代言人（立刻审查）：
"这里有个安全漏洞，SQL 注入风险"
  ↓
前端智能体（立刻修复）：
"好的，我用参数化查询"
  ↓
问题在早期解决，不会积累成大坑
```

---

# 第四部分：Opus 4.6 模型升级

## 1. 更聪明的任务编排（Orchestration）

**是什么：** 模型更知道"什么时候该叫谁"。

**通俗类比：** 就像一个聪明的项目经理：
- **不太聪明的项目经理** = 看到什么事都自己干，累死效率还低
- **聪明的项目经理** = 知道什么事该叫谁，自己只做最核心的决策

**Opus 4.6 的改进：**
- 更敏锐地判断任务复杂度
- 知道什么时候该委派给专业智能体
- 资源分配更高效

## 2. 超长上下文（100 万 Token）

**是什么：** 模型可以"记住"更多内容。

**通俗类比：**
- **普通模型** = 记忆像一张小纸条，写满了就得擦掉旧的
- **Opus 4.6** = 记忆像一本厚书，可以记录很多东西

**数据对比：**
- **100 万 Token** ≈ 75 万汉字 ≈ 几本长篇小说

**但是！**
- 目前 Opus 4.6 的 100 万 Token 还没加入标准订阅
- Claude Code 工具本身可能还用不了这么大的上下文
- 不过 Opus 4.6 在长会话中的信息留存能力已经大幅提升

## 3. 努力程度调节（Effort Levels）

**是什么：** 你可以动态调节 AI 的"思考深度"。

**通俗类比：** 就像汽车的驾驶模式：
- **经济模式（低）** = 省油，够用就行（适合城市道路）
- **普通模式（中）** = 平衡（适合日常驾驶）
- **运动模式（高）** = 性能全开（适合高速或山路）

| 努力程度 | 适合场景 | 成本 |
|---------|----------|------|
| **低（Low）** | 语法检查、简单脚本修改 | 便宜、快速 |
| **中（Medium）** | 智能体任务、日常开发 | 平衡 |
| **高（High）** | 复杂架构重构、深层调试 | 贵、但质量最高 |

**实际使用：**
```
场景1：检查代码有没有语法错误
→ 用"低"就够了，秒出结果

场景2：实现一个新功能
→ 用"中"，平衡速度和质量

场景3：调试一个困扰你一周的 Bug
→ 用"高"，让 AI 深度思考
```

---

# 第五部分：自动记忆功能（Auto-memory）

## 是什么

**通俗类比：** 就像一个"自动记笔记"的助理：
- 每次解决一个问题，它就记下来
- 下次遇到同样问题，它翻开笔记
- 不用重新解决，直接用之前的方案

## 运作机制

**系统提示词：**
```
"工作时，查阅你的记忆文件，利用之前的经验。
如果遇到一个可能常见的错误，检查自动记忆。
如果没记录，把学到的东西记下来。"
```

**文件结构：**
```
.claude/
├── memory/
│   ├── index.md           # 主索引（像书的目录）
│   ├── database-bugs.md   # 数据库相关错误
│   ├── api-design.md      # API 设计经验
│   └── frontend-tips.md   # 前端开发技巧
```

**为什么用"索引-主题"结构：**

**不用索引结构（不好）：**
```
memory.md（一个巨大的文件，200 页）
  ↓
AI 每次都要读完整本 200 页
  ↓
很慢，而且会被无关信息干扰
```

**用索引结构（好）：**
```
index.md（只有目录）
  ↓
AI 只需要读目录
  ↓
遇到数据库问题，只打开 database-bugs.md
  ↓
快速、精准、不被干扰
```

## 开发者价值

| 价值 | 说明 |
|------|------|
| **跨对话经验留存** | 不会"重复踩同一个坑" |
| **自动学习** | 不用手动记，AI 自动总结 |
| **按需加载** | 只读取相关的记忆，不浪费时间 |

## 记忆修剪（Pruning）

**问题：** 记忆多了会有"噪音"

**类比：** 就像你的手机相册：
- 刚开始：几张照片，清晰
- 几年后：几千张照片，很多重复的、模糊的
- 需要定期清理

**建议：**
- 定期（比如每月）检查记忆文件
- 删除过时的、错误的、无用的记录
- 保持记忆库的"干净"

---

# 第六部分：开发者工具与用户体验

## 新增命令

### 1. /copy 命令

**是什么：** 快速复制 AI 最后一次的输出。

**通俗类比：** 以前你复制 AI 的输出要：
1. 用鼠标选中
2. 右键复制
3. 粘贴到别处

现在：
```
/copy
```
就完成了。

### 2. GitHub CLI 深度集成

**是什么：** 在终端直接看到 PR 状态。

**通俗类比：** 以前你要：
1. 打开浏览器
2. 登录 GitHub
3. 找到 PR
4. 看状态

现在：
```
终端状态栏直接显示：
PR #123: ✅ 已通过检查，可以合并
```

点击就能直接跳转。

### 3. /keybindings

**是什么：** 查看和自定义快捷键。

**通俗类比：** 就像游戏的"按键设置"，你可以改成自己习惯的。

## Token 效率优化

### Schema-optimized tools

**问题：** 以前用 Bash 命令读取文件，会加载很多"元数据"（metadata），浪费 token。

**类比：**
- **用 Bash** = 让 AI 读整本书，包括封面、目录、版权页（都是废话）
- **用专用工具** = 让 AI 直接读正文，跳过废话

**优化效果：**
- 长会话中更省 token
- 响应更快
- 成本更低

---

# 第七部分：Agent Teams 实践部署

## 环境配置

### 1. 开启功能

**配置文件：** `.claude/settings.local.json`

```json
{
  "AGENT_TEAMS_ENABLED": true,
  "AGENT_TEAMS_KEY": "your-key-here"
}
```

### 2. 多窗口模式

**强烈推荐：** 使用 Tmux 或 iTerm2 分屏

**布局：**
```
┌─────────────┬─────────────┬─────────────┐
│  主智能体    │  后端智能体  │  前端智能体  │
│  (Leader)   │  (Backend)  │  (Frontend) │
│             │             │             │
│  统筹全局    │  写 API     │  写界面     │
└─────────────┴─────────────┴─────────────┘
```

**好处：**
- 同时监控所有智能体的对话
- 实时看到他们在说什么
- 发现问题立刻介入

## 文件结构

```
.claude/teams/
├── config          # 团队配置
│                   # - 谁是成员
│                   # - 每个 AI 的专属指令
│                   # - 用哪个模型（Opus/Sonnet/Haiku）
│
├── tasks           # 任务列表快照
│                   # - 所有任务的状态
│                   # - 谁在做什么
│                   # - 哪些任务被阻断
│
└── inboxes         # 消息历史（重要！）
                    # - 所有智能体之间的对话
                    # - 协作决策的完整记录
                    # - 出问题时可以回溯
```

---

# 第八部分：实战案例 - 10 万行 C 编译器

## 项目规模

**产出：** 一个完整的 C 语言编译器（10 万行代码）

**投入：**
- 2,000+ 次 Claude Code 会话
- $20,000 美元的 API 成本

**类比：**
- **10 万行代码** ≈ 写一本 3000 页的书
- **$20,000** ≈ 雇一个高级工程师 2-3 个月的工资

## 核心技术路径

### Ralph 循环（Ralph Loop）

**是什么：** 一种强化反馈机制。

**通俗类比：** 就像运动训练中的"录像分析"：
1. 运动员做动作
2. 教练录像
3. 一起回看录像
4. 找出问题
5. 纠正动作
6. 再做、再录、再看、再纠正
7. 循环往复，不断改进

**在编译器项目中：**
1. AI 写代码
2. 运行测试
3. 分析失败原因
4. 记录到"记忆"中
5. 下次避免同样的错误
6. 循环往复，代码质量不断提升

### Agent Teams 协作

**团队角色：**
- **Leader** = 总架构师（设计编译器整体结构）
- **词法分析团队** = 负责把代码拆成 token
- **语法分析团队** = 负责解析语法树
- **优化团队** = 负责代码优化
- **代码生成团队** = 负责生成机器码
- **测试团队** = 负责测试和验证

**协作方式：**
- 通过收件箱系统实时沟通
- 共享任务列表管理进度
- 阻断器确保依赖正确

## 案例启示

这个案例证明了：
> **在充足的算力支持下，AI 团队已经具备构建底层复杂软件的能力。**

**类比：**
- 以前 AI 只能帮你"写函数"
- 现在 AI 团队可以帮你"写编译器"
- 这是质变，不是量变

---

# 总结：5 条核心原则

## 1. 协作 > 单干

**类比：** 一个专业团队 > 一个万能工人

**实践：**
- 用 Agent Teams 处理复杂项目
- 让每个智能体做自己擅长的事
- 通过收件箱系统保持同步

## 2. 沟通是关键

**类比：** 团队协作最怕"信息孤岛"

**实践：**
- 利用收件箱系统实时沟通
- 有疑问立刻问，不要瞎猜
- 记录所有决策过程（inboxes）

## 3. 记忆要积累

**类比：** 经验是最好的老师

**实践：**
- 开启自动记忆功能
- 定期修剪记忆库，删除噪音
- 跨对话复用经验

## 4. 工具要用好

**类比：** 好工具让效率翻倍

**实践：**
- 使用 /copy 快速复制
- 利用 GitHub 集成查看 PR
- 用专用工具节省 token

## 5. 规模要适度

**类比：** 不是所有项目都需要 100 人的团队

**实践：**
- 小项目：单个 AI 够了
- 中等项目：2-3 个智能体
- 大项目（如编译器）：完整团队

---

# 最终类比：经营一家公司

**把 Agent Teams 想象成经营一家软件公司：**

| 概念 | 公司类比 | Agent Teams |
|------|----------|-------------|
| **Leader** | CEO/项目经理 | 主智能体（统筹全局） |
| **团队成员** | 员工（前端、后端、测试） | 子智能体（各司其职） |
| **任务列表** | 项目管理软件（Jira） | 共享任务列表 |
| **阻断器** | 任务依赖管理 | Blockers 机制 |
| **收件箱** | 内部聊天软件（钉钉） | Inbox 系统 |
| **自动记忆** | 公司知识库 | Auto-memory |
| **努力程度** | 项目优先级 | Effort Levels |

**最终目标：**

> 不再是一个"万能工人"，而是一整支"虚拟工程团队"为你工作。

---

## 参考资源

- Anthropic: "Claude Code Best Practices" (2025)
- Ralph Loop: 强化反馈机制
- Agent Teams 官方文档
- Opus 4.6 模型更新日志

---

*来源：YouTube 视频内容总结*
*本文由文科生友好的比喻改编*
*配合《Claude Code 深度技巧》和《Claude Code 进阶技巧》一起阅读效果更佳*
