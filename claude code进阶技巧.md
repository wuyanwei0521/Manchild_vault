# Claude Code 进阶技巧 - 从入门到精通

## 概述

上一篇文章《Claude Code 深度技巧》是"入门手册"，教你如何配置基础设置（技能、钩子、子代理、MCP、插件）。

**这一篇是"进阶指南"**，教你在配置好之后，如何**高效使用**这些工具。

**通俗类比：**
- **入门手册** = 买咖啡机时附带的说明书（教你组装、开机、基本操作）
- **进阶指南** = 咖啡师培训课程（教你选豆子、调整研磨度、拉花艺术、保养技巧）

---

## 本章主题：5个进阶方向

1. **Token 经济学** = 如何"省钱"（控制使用成本）
2. **记忆持久化** = 如何让 AI"记住"昨天的对话
3. **验证模式** = 如何确保 AI 做的事情是对的
4. **并行化策略** = 如何让多个 AI 同时干活
5. **可重用工作流** = 如何一劳永逸地建立"标准流程"

---

# 第一部分：让 AI "记住"昨天的事

## 问题场景

**通俗类比：** 想象你的记性不太好：
- 第一天：你和同事讨论了一个项目，记在脑子里
- 第二天：你忘了昨天的讨论，同事又给你讲一遍
- 第三天：你又忘了，同事再讲一遍...

**在 Claude Code 中：**
- 昨天你让 Claude 记住了项目的特殊规则
- 今天重新打开对话，Claude 全忘了
- 你又得重新告诉它这些规则

**结果：** 浪费时间、浪费 token（钱）、重复劳动

## 解决方案1：会话日志模式（Session Log Pattern）

**是什么：** 在每个会话结束时，把重要信息保存到一个 `.tmp` 文件里。

**通俗类比：** 就像写工作日记：
- 每天下班前，写下今天做了什么
- 哪些方法有效
- 哪些方法无效
- 明天该继续做什么

第二天上班时，先读昨天的日记，就能快速接上进度。

**具体做法：**

### 步骤1：创建会话总结技能

创建一个技能，让 Claude 在会话结束时自动总结：

```bash
# 文件位置：~/.claude/skills/session-saver.md
```

**技能内容：**
- 当前状态：我们做到了哪一步？
- 有效的做法：哪些方法确实有效（有证据）
- 无效的做法：试过哪些方法但失败了
- 待办事项：还有什么没做

### 步骤2：保存到文件

```bash
# 文件命名格式
~/.claude/sessions/2025-02-07-项目名称.tmp
```

**文件内容示例：**
```markdown
# 2025-02-07 会话日志

## 当前进度
- 完成了用户认证模块
- 正在开发订单系统

## 有效的做法 ✅
- 使用 Supabase Auth 进行认证（已验证可行）
- 用 TypeScript 严格模式防止类型错误

## 无效的做法 ❌
- 尝试用 OAuth 2.0，但文档不完整，放弃

## 待办事项 📋
- 完成订单 API
- 编写单元测试
- 部署到 Vercel
```

### 步骤3：下次会话开始时加载

新对话开始时，告诉 Claude：
```
"请先阅读 ~/.claude/sessions/2025-02-07-项目名称.tmp，然后基于这个文件继续工作"
```

**好处：**
- Claude 立刻知道项目背景
- 不会重复错误的尝试
- 节省大量 token（不用重新解释）

## 解决方案2：自动化记忆钩子（Memory Persistence Hooks）

**是什么：** 在会话开始、压缩、结束时自动运行的"记忆程序"。

**通俗类比：** 就像智能家居系统：
- **你到家时**（会话开始）：灯光自动调到你喜欢的亮度，音乐自动播放
- **你离开前**（会话压缩前）：系统自动保存你今天看的节目、听的歌
- **你离开后**（会话结束）：系统自动整理今天的记录，明天准备好

### 三个关键钩子

#### 1. SessionStart Hook（会话开始钩子）

**什么时候触发：** 每次启动新对话时

**做什么：**
- 检查最近 7 天的会话文件
- 提醒你有可用的历史记录
- 加载相关背景

**类比：** 就像你每天上班时，助理递给你昨天的会议纪要

#### 2. PreCompact Hook（压缩前钩子）

**什么时候触发：** 上下文窗口快满，需要压缩时

**做什么：**
- 保存当前状态到文件
- 记录哪些决策已做
- 标记当前进度

**类比：** 就像你搬家时，在打包箱子前先写个清单，里面有什么、放在哪

#### 3. Stop Hook（会话结束钩子）

**什么时候触发：** 会话结束时

**做什么：**
- 创建每日会话文件
- 记录开始/结束时间
- 保存学到的经验

**类比：** 就像每天下班前写工作日志

### 钩子配置示例

```json
{
  "hooks": {
    "PreCompact": [{
      "matcher": "*",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/hooks/memory-persistence/pre-compact.sh"
      }]
    }],
    "SessionStart": [{
      "matcher": "*",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/hooks/memory-persistence/session-start.sh"
      }]
    }],
    "Stop": [{
      "matcher": "*",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/hooks/memory-persistence/session-end.sh"
      }]
    }]
  }
}
```

**效果：**
- 三个钩子串联起来，形成"记忆链"
- 无需手动干预，自动管理记忆
- 多天会话无缝衔接

## 解决方案3：持续学习系统（Continuous Learning）

**是什么：** 让 Claude 自动从错误中学习，并保存为"经验教训"。

**通俗类比：** 就像一个会记笔记的学徒：
- 第一次做错一件事
- 你纠正他
- 他把纠正方法记在笔记本上
- 下次遇到类似问题，他自己翻笔记本，不再犯同样的错

### 问题场景

**你可能遇到过：**
```
你：Claude，不要用 console.log，用 logger
Claude：好的，明白了

（10分钟后）
Claude：*又用了 console.log*
你：我都说了不要用 console.log！
Claude：抱歉，我忘了
```

**为什么会这样：**
- Claude 的记忆有限
- 对话长了，早期的指令会被"挤出"上下文窗口
- 每次"纠正"都浪费 token

### 解决方案：Stop Hook + 自动学习

**工作原理：**

```
会话中
    │
    ▼
你纠正 Claude
    │
    ▼
会话结束
    │
    ▼
Stop Hook 触发
    │
    ├──► 分析整个会话
    │
    ├──► 找出"纠正模式"
    │
    └──► 自动保存为技能

下次会话
    │
    └──► 自动加载这个技能
    │
    └──► 不再犯同样的错
```

### 实际安装

```bash
# 克隆到技能文件夹
git clone https://github.com/affaan-m/everything-claude-code.git \
  ~/.claude/skills/everything-claude-code

# 或者只下载持续学习技能
mkdir -p ~/.claude/skills/continuous-learning
curl -sL https://raw.githubusercontent.com/affaan-m/everything-claude-code/main/skills/continuous-learning/evaluate-session.sh \
  > ~/.claude/skills/continuous-learning/evaluate-session.sh
chmod +x ~/.claude/skills/continuous-learning/evaluate-session.sh
```

### Hook 配置

```json
{
  "hooks": {
    "Stop": [{
      "matcher": "*",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/skills/continuous-learning/evaluate-session.sh"
      }]
    }]
  }
}
```

**它做什么：**
1. 会话结束时自动运行
2. 分析整个对话，找出"值得记住的经验"
3. 自动创建技能文件，保存在 `~/.claude/skills/learned/`
4. 下次会话自动加载

**例子：**
```markdown
# ~/.claude/skills/learned/no-console-log.md

## 规则：永远不要使用 console.log

**原因：** 用户明确要求使用 logger 而不是 console.log

**正确做法：**
```typescript
import { logger } from './utils/logger';

logger.info('用户登录');  // ✅ 正确
```

**错误做法：**
```typescript
console.log('用户登录');  // ❌ 错误
```
```

### 手动提取：/learn 命令

**不必等到会话结束：**

刚解决了一个难题？立即运行 `/learn`

Claude 会：
1. 询问你学到了什么
2. 起草一个技能文件
3. 让你确认
4. 保存为可重用的技能

---

# 第二部分：Token 经济学 - 如何"省钱"

## 问题的本质

**通俗类比：** 想象你打电话：
- **输入 token** = 你说的话（每字 5 元）
- **输出 token** = 对方说的话（每字 25 元）
- **上下文窗口** = 你的记忆容量（最多记住 15 万字）

**为什么输出更贵：**
- 生成代码比阅读代码更难
- AI 需要思考和推理
- 计算量更大

## 策略1：智能模型选择

**是什么：** 根据任务难度，选择不同"级别"的 AI 模型。

**通俗类比：** 就像雇人干活：
- **Haiku** = 实习生（便宜、快，但只能做简单任务）
- **Sonnet** = 正式员工（中等价格、速度，能做大部分任务）
- **Opus** = 专家（贵、慢，但能处理最复杂的问题）

### 三层模型策略

| 模型 | 价格 | 适合任务 | 不适合任务 |
|------|------|----------|------------|
| **Haiku** | 最便宜 | 简单搜索、格式化代码、翻译 | 架构设计、复杂调试 |
| **Sonnet** | 中等 | 90% 的日常编程任务 | 跨文件重构、安全关键代码 |
| **Opus** | 最贵 | 架构决策、安全审查、首次尝试失败的任务 | 简单重复任务 |

### 成本对比

```
Opus:  $15/百万输入 + $75/百万输出
Sonnet: $3/百万输入  + $15/百万输出  (省 66%)
Haiku:  $0.25/百万输入 + $1.25/百万输出 (省 98%)
```

**实战建议：**

1. **默认用 Sonnet** 做 90% 的任务
2. **升级到 Opus** 当：
   - Sonnet 第一次尝试失败
   - 任务涉及 5+ 个文件
   - 需要架构决策
   - 安全关键代码

3. **降级到 Haiku** 当：
   - 任务简单重复
   - 指令非常明确
   - 作为"工人"在多代理系统中

### 子代理模型配置

```yaml
# ~/.claude/agents/quick-search.md
---
name: quick-search
description: 快速文件搜索
tools: Glob, Grep
model: haiku  # 便宜且快
---

# ~/.claude/agents/architect.md
---
name: architect
description: 系统架构设计
tools: Read, Write, Edit
model: opus  # 贵但可靠
---
```

## 策略2：工具优化

### 问题：默认工具很"浪费"

**例子：grep vs mgrep**

```
任务：搜索 "function handleSubmit"

传统 grep:
- 返回 50 行代码
- 5000 tokens

mgrep:
- 返回精确匹配的 5 行
- 500 tokens (省 90%)
```

### 解决方案：用更好的工具

```bash
# 安装 mgrep 插件
claude plugin marketplace add https://github.com/mixedbread-ai/mgrep

# 使用
mgrep "function handleSubmit"        # 本地搜索
mgrep --web "Next.js 15 新特性"      # 网络搜索
```

## 策略3：后台进程处理

**是什么：** 把不需要 AI 实时处理的任务放到后台。

**通俗类比：**
- **不用后台** = 你站在洗衣机旁等衣服洗完
- **用后台** = 你把衣服放进洗衣机，去干别的事，洗完再回来

### 实际场景

```bash
# 场景：运行测试套件（需要 10 分钟）

# 不推荐：让 Claude 等待
Claude: 运行测试...
# (Claude 在这里等 10 分钟，浪费 token)

# 推荐：用 tmux 后台运行
tmux new -s test
npm test
# (Ctrl+B 然后 D，detach)
# Claude 可以继续做别的事
```

**好处：**
- Claude 不用"等待"输出
- 节省大量输入 token
- 可以并行处理多个任务

## 策略4：模块化代码库

**是什么：** 把大文件拆分成小文件。

**通俗类比：**
- **不模块化** = 一本 1000 页的书，找一句话要翻半天
- **模块化** = 10 本 100 页的小册子，每本讲一个主题，快速定位

### 对 token 的影响

```
# 不模块化
src/
├── app.ts (5000 行)
└── utils.ts (3000 行)

问题：
- Claude 要多次调用 Read 工具才能读完
- 可能丢失中间信息
- 反复读取浪费 token

# 模块化
src/
├── app/
│   ├── routes.ts       (200 行)
│   ├── controllers.ts  (200 行)
│   └── middleware.ts   (200 行)
└── utils/
    ├── string.ts       (100 行)
    ├── date.ts         (100 行)
    └── array.ts        (100 行)

好处：
- 一次读取就能理解
- 不会丢失信息
- 只读需要的部分
```

### 模块化架构示例

```
root/
├── docs/           # 全局文档
├── scripts/        # CI/CD 和构建脚本
├── src/
│   ├── apps/       # 入口点（API、CLI、Workers）
│   ├── modules/    # 核心业务逻辑
│   │   ├── ordering/    # 订单模块（自包含）
│   │   │   ├── api/     # 公共接口
│   │   │   ├── domain/  # 业务逻辑
│   │   │   └── tests/   # 测试
│   │   ├── catalog/     # 目录模块（自包含）
│   │   └── identity/    # 用户模块（自包含）
│   └── shared/     # 共享代码
│       ├── kernel/  # 基础类
│       └── utils/   # 工具函数
```

**好处：**
- 每个模块独立（几百行，不是几千行）
- 容易理解
- token 效率高
- 一次就能做对（不需要反复尝试）

## 策略5：精简代码库

**是什么：** 定期清理死代码和无用文件。

**通俗类比：** 定期整理衣柜：
- 扔掉不穿的衣服
- 把常用的放在容易拿到的位置
- 衣柜空间更大，找东西更快

### 自动清理

```bash
# 使用 refactor-clean 技能
/refactor-clean
```

**它做什么：**
- 删除未使用的导入
- 删除死代码（没有被调用的函数）
- 删除重复代码
- 删除无用的 .md 文件

### 手动检查

定期（比如每周）：
1. 快速浏览整个代码库
2. 找出"看起来重复"的代码
3. 手动整理上下文
4. 喂给 Claude + refactor-clean 技能

---

# 第三部分：上下文管理 - 战略性压缩

## 问题：上下文窗口会"满"

**通俗类比：** 想象你的书桌：
- 刚开始工作：书桌是空的，只有必要的书
- 工作 1 小时：书桌上堆了很多书、文件、咖啡杯
- 工作 2 小时：书桌满了，找不到东西，效率下降

**在 Claude Code 中：**
- 对话长了，上下文窗口满了
- 早期的对话被"压缩"（可能丢失重要信息）
- Claude 开始"忘记"之前说的规则

## 解决方案1：战略性压缩

**是什么：** 在"合适的时机"手动压缩，而不是自动压缩。

**通俗类比：**
- **自动压缩** = 你正在做饭，突然有人把你厨房整理了一遍，东西找不到了
- **战略压缩** = 一道菜做完，收拾干净，再做下一道菜

### 什么时候压缩？

**合适的时机：**
- ✅ 探索阶段结束，开始执行
- ✅ 完成一个里程碑，开始下一个
- ✅ 调试完成，开始新任务

**不合适的时机：**
- ❌ 任务进行到一半
- ❌ 正在调试问题
- ❌ 需要回顾之前的决策

### 战略压缩脚本

```bash
#!/bin/bash
# ~/.claude/hooks/strategic-compact.sh

COUNTER_FILE="/tmp/claude-tool-count-$$"
THRESHOLD=${COMPACT_THRESHOLD:-50}

# 初始化或增加计数器
if [ -f "$COUNTER_FILE" ]; then
  count=$(cat "$COUNTER_FILE")
  count=$((count + 1))
  echo "$count" > "$COUNTER_FILE"
else
  echo "1" > "$COUNTER_FILE"
  count=1
fi

# 达到阈值时提醒
if [ "$count" -eq "$THRESHOLD" ]; then
  echo "[战略压缩] 已进行 $THRESHOLD 次工具调用 - 如果正在切换阶段，考虑运行 /compact" >&2
fi
```

### Hook 配置

```json
{
  "PreToolUse": [{
    "matcher": "Edit|Write",
    "hooks": [{
      "type": "command",
      "command": "~/.claude/hooks/strategic-compact.sh"
    }]
  }]
}
```

**效果：**
- 每 50 次工具调用，提醒你考虑压缩
- 你可以决定是否真的压缩
- 在合适的时机压缩，保留重要信息

## 解决方案2：动态系统提示注入

**是什么：** 用命令行参数动态加载上下文，而不是每次都加载所有规则。

**通俗类比：**
- **传统方式** = 每天上班都带上 10 本手册（不管用不用）
- **动态注入** = 今天要做代码审查，只带《代码审查手册》

### 两种方式对比

| 方式 | 权威级别 | 何时使用 |
|------|----------|----------|
| `.claude/rules/` | 中等（用户消息级别） | 基础项目规则，每次会话都需要 |
| `--system-prompt` | 高（系统级别） | 特定场景，偶尔需要 |

### 实际设置

```bash
# 创建不同场景的上下文文件
~/.claude/contexts/dev.md       # 日常开发
~/.claude/contexts/review.md    # PR 审查
~/.claude/contexts/research.md  # 研究/探索
```

```bash
# 创建别名
alias claude-dev='claude --system-prompt "$(cat ~/.claude/contexts/dev.md)"'
alias claude-review='claude --system-prompt "$(cat ~/.claude/contexts/review.md)"'
alias claude-research='claude --system-prompt "$(cat ~/.claude/contexts/research.md)"'
```

**使用：**
```bash
# 日常开发
claude-dev

# PR 审查模式
claude-review

# 研究模式
claude-research
```

### 上下文文件内容示例

**dev.md（日常开发）：**
```markdown
# 日常开发规则

1. 优先实现功能，其次优化
2. 使用 TypeScript 严格模式
3. 每个功能必须有单元测试
4. 不要过度工程化
```

**review.md（PR 审查）：**
```markdown
# PR 审查规则

1. 重点关注代码质量和安全
2. 检查是否有测试覆盖
3. 确保没有硬编码密钥
4. 代码风格符合项目规范
```

**research.md（研究/探索）：**
```markdown
# 研究模式规则

1. 先探索，后行动
2. 记录所有发现
3. 不要急于写代码
4. 优先理解问题域
```

**好处：**
- 更快的加载速度（不用调用 Read 工具）
- 更可靠（系统级别权威）
- 更省 token
- 针对性更强

---

# 第四部分：验证模式 - 确保 AI 做对了

## 为什么需要验证？

**通俗类比：** 想象你雇了个助理：
- 你让他做个报表
- 他做完了
- 你需要检查一遍，确保没错

**在 Claude Code 中：**
- Claude 写完代码
- 你需要验证代码是否正确
- 是否符合要求
- 是否有 bug

## 验证模式1：基于检查点的验证

**是什么：** 在工作的关键节点设置"检查点"，必须通过验证才能继续。

**通俗类比：** 就像电子游戏：
- 通过第 1 关 → 检查点1 → 检查装备 → 继续第 2 关
- 通过第 2 关 → 检查点2 → 检查血量 → 继续第 3 关
- 检查点不通过 → 必须解决当前关卡的问题才能继续

### 工作流程

```
[任务 1]
    │
    ▼
┌─────────┐
│检查点 1 │◄─── 验证标准
└────┬────┘
     │
     ▼
  通过了吗？
     │
  ┌──┴──┐
  │    │
 是    否
  │    │
  ▼    ▼
[任务 2] 修复
  │
  ▼
┌─────────┐
│检查点 2 │
└─────────┘
```

### 实际例子

**任务：实现用户认证功能**

```markdown
## 检查点 1：设计完成

验证标准：
- [ ] 有完整的流程图
- [ ] 定义了 API 接口
- [ ] 列出了需要的依赖

不通过 → 重新设计

---

## 检查点 2：测试通过

验证标准：
- [ ] 所有单元测试通过
- [ ] 测试覆盖率达到 80%
- [ ] 集成测试通过

不通过 → 修复测试

---

## 检查点 3：代码审查通过

验证标准：
- [ ] 代码符合风格规范
- [ ] 没有安全隐患
- [ ] 没有硬编码密钥

不通过 → 修复代码
```

## 验证模式2：连续验证

**是什么：** 每隔 N 分钟或重大变更后，自动运行完整测试。

**通俗类比：** 就像工厂的流水线：
- 每个零件生产完 → 立即质检
- 质检不通过 → 立即停线修复
- 质检通过 → 继续生产下一个

### 适合场景

| 模式 | 适合场景 | 不适合场景 |
|------|----------|------------|
| **检查点验证** | 线性工作流，有明确里程碑 | 探索性编程 |
| **连续验证** | 长时间会话，频繁变更 | 快速原型开发 |

### 连续验证设置

```bash
# ~/.claude/hooks/continuous-eval.sh
#!/bin/bash

# 每 15 分钟运行一次完整验证
LAST_RUN_FILE="/tmp/claude-last-eval"
INTERVAL=900  # 15 分钟（秒）

if [ -f "$LAST_RUN_FILE" ]; then
  last_run=$(cat "$LAST_RUN_FILE")
  now=$(date +%s)
  diff=$((now - last_run))

  if [ $diff -gt $INTERVAL ]; then
    echo "[连续验证] 运行完整测试套件..." >&2
    npm test
    npm run lint
    date +%s > "$LAST_RUN_FILE"
  fi
else
  date +%s > "$LAST_RUN_FILE"
fi
```

```json
{
  "PostToolUse": [{
    "matcher": "Edit|Write",
    "hooks": [{
      "type": "command",
      "command": "~/.claude/hooks/continuous-eval.sh"
    }]
  }]
}
```

## 评估指标：pass@k vs pass^k

**是什么：** 衡量 AI 成功率的两种方式。

**通俗类比：**
- **pass@k** = "至少有一次成功就行"（像考试，允许重考）
- **pass^k** = "每次都要成功"（像空中飞人，每次都要成功）

### 例子

```
假设尝试 5 次，成功率 70%

pass@k（至少一次成功）：
- k=1: 70%
- k=3: 91% （尝试 3 次，至少成功 1 次的概率）
- k=5: 97% （尝试 5 次，至少成功 1 次的概率）

pass^k（每次都要成功）：
- k=1: 70%
- k=3: 34%  （3 次都成功的概率）
- k=5: 17%  （5 次都成功的概率）
```

### 何时使用哪个

| 指标 | 使用场景 | 要求 |
|------|----------|------|
| **pass@k** | 只要能工作就行，允许重试 | 灵活性高，容错性强 |
| **pass^k** | 必须每次都成功，要求一致性 | 严格要求，质量至上 |

### 实际例子

**pass@k 场景：**
```
任务：生成一段代码

允许重试 3 次：
- 第 1 次：代码有小 bug
- 第 2 次：修复了 bug，成功！
→ 算 pass@3=1 （3 次内成功）
```

**pass^k 场景：**
```
任务：批量处理 100 个用户数据

要求：
- 每个用户都必须处理成功
- 如果有 1 个失败，整个任务失败

需要：
- 更严格的验证
- 可能需要用 Opus 而不是 Haiku
- 更多的错误处理
→ 追求 pass^100 的高成功率
```

---

# 第五部分：并行工作流 - 多个 AI 同时干活

## 核心理念：最小可行并行化

**通俗类比：**
- **过度并行** = 雇 10 个助理，但只有 3 件事要做，7 个助理闲着，浪费钱
- **合理并行** = 雇 3 个助理，正好每人一件事，效率最大化

**作者的建议：**
- 大多数时候，2-3 个 Claude 实例就够了
- 不要为了并行而并行
- 并行应该出于"真正的需要"

## 并行模式1：双实例启动模式

**是什么：** 新项目启动时，用 2 个 Claude 实例各做不同的事。

**通俗类比：** 就像开餐厅：
- **实例1（装修团队）** = 负责搭架子、布局、装修
- **实例2（研发团队）** = 负责研究菜单、试菜、设计菜品
- 两个团队同时工作，互不干扰

### 实例 1：脚手架代理（Scaffolding Agent）

**做什么：**
- 搭建项目结构
- 配置开发环境
- 设置工具（ESLint、Prettier、Jest）
- 建立代码规范
- 创建基础文件

**类比：** 就像盖房子先搭框架、通水电

### 实例 2：深度研究代理（Deep Research Agent）

**做什么：**
- 连接外部服务
- 搜索相关文档
- 创建详细的 PRD（产品需求文档）
- 画架构图（Mermaid 图表）
- 收集最佳实践

**类比：** 就像开餐厅前研究菜单、考察市场

### 物理布局

```
┌─────────────────┬─────────────────┐
│  左终端          │  右终端          │
│  (编码)         │  (研究)         │
│                 │                 │
│  脚手架代理      │  研究代理        │
│  - 搭建结构      │  - PRD          │
│  - 配置工具      │  - 架构图        │
│  - 建立规范      │  - 文档研究       │
│                 │                 │
│  使用 /rename    │  使用 /rename    │
└─────────────────┴─────────────────┘
```

## 并行模式2：Git Worktrees（平行宇宙）

**是什么：** 同一个项目的多个独立版本，互不干扰。

**通俗类比：** 想象你在写小说：
- **主版本** = 桌面上的"小说最终版.docx"
- **平行宇宙 A** = 文件夹"实验A-改变结局版"里的"小说.docx"
- **平行宇宙 B** = 文件夹"实验B-换个主角版"里的"小说.docx"

三个版本互不影响，你可以同时尝试不同的创意。

### 实际操作

```bash
# 创建 3 个工作树
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b
git worktree add ../project-refactor refactor-branch

# 每个工作树运行一个 Claude 实例
cd ../project-feature-a && claude
cd ../project-feature-b && claude
cd ../project-refactor && claude
```

### 好处

| 好处 | 说明 |
|------|------|
| **无 Git 冲突** | 每个工作树独立的 git 历史 |
| **干净的工作目录** | 不会互相干扰 |
| **容易比较** | 可以对比不同方案的产出 |
| **基准测试** | 同一个任务，用不同方法做，比较效果 |

### 使用 /rename 避免混淆

```bash
# 每个对话都重命名，避免忘记哪个是哪个
/rename feature-a-用户认证
/rename feature-b-订单系统
/rename refactor-数据库优化
```

## 并行模式3：瀑布流方法（Cascade Method）

**是什么：** 有序地管理多个并行任务。

**通俗类比：** 就像餐厅厨房的订单系统：
- 新订单从右边进来
- 从左到右处理（旧 → 新）
- 维持一致的方向流

### 操作方法

1. **新任务在新标签页打开**（在现有标签页的右边）
2. **从左到右扫描**（从最旧到最新）
3. **保持一致的方向**
4. **最多同时关注 3-4 个任务**

### 为什么是 3-4 个？

**心理负荷曲线：**
```
  效率
    ▲
    │         ┌─────
    │        /       ┌──
    │       /       /
    │   ────       /
    │  /          /
    │ /          /
    └────────────────── 任务数
      1  2  3  4  5  6

最优点：3-4 个任务
超过 4 个：心理负荷增加快于效率提升
```

## 并行模式4：分叉对话（/fork）

**是什么：** 从主对话"分叉"出一个独立的对话，做不重叠的任务。

**通俗类比：**
- **不用 /fork** = 你一个人，先切菜，再炒菜，再煲汤（慢）
- **用 /fork** = 你雇 3 个助手，一个切菜，一个炒菜，一个煲汤（快）

### 何时使用 /fork

| 场景 | 使用 /fork | 不用 /fork |
|------|------------|------------|
| **独立任务** | ✅ 任务 A 和任务 B 完全无关 | ❌ 任务 B 依赖任务 A |
| **不同关注点** | ✅ 一个写代码，一个查文档 | ❌ 都在改同一个文件 |
| **紧急程度不同** | ✅ 重要任务在主对话，次要任务 fork | ❌ 都很紧急且相关 |

### 作者的个人偏好

```markdown
主对话：代码变更
  ↓
fork 1：代码库问题研究
fork 2：外部服务文档查找
fork 3：GitHub 开源库搜索
```

**为什么？**
- 主对话专注于"写代码"
- fork 用来"查找信息"
- 最小化代码变更的重叠
- 避免 merge 冲突

---

# 第六部分：子代理编排 - 让 AI 团队协作

## 子代理上下文问题

**是什么：** 子代理缺少主编排器拥有的"隐式上下文"。

**通俗类比：**
- **主编排器（老板）** = 知道整个项目的背景、目标、历史
- **子代理（员工）** = 只知道具体任务，不知道"为什么要这样做"

### 问题场景

```
老板：你去参加这个会议，回来告诉我讨论了什么

员工（参加完会议）：
- 讨论了 A 方案
- 讨论了 B 方案
- 决定下周再议

老板：
- A 方案的背景是什么？
- B 方案有什么风险？
- 为什么要下周再议？

员工的总结缺少老板需要的"隐式上下文"
```

### 在 Claude Code 中

```
主编排器：
"项目要求高性能，用 Go 重写这个模块"
  ↓
子代理：
"好的，我来重写..."
[重写完成，但用的是 Python]
  ↓
主编排器：
"我说的 Go 语言，你怎么用 Python？"
  ↓
子代理：
"啊，我不知道..."
```

## 解决方案：迭代检索模式

**是什么：** 让主编排器"追问"子代理，直到获得完整信息。

**工作流程：**

```
┌─────────────────┐
│  主编排器        │
│  (有完整上下文)  │
└────────┬────────┘
         │ 发送查询 + 目标
         ▼
┌─────────────────┐
│   子代理        │
│  (缺少上下文)   │
└────────┬────────┘
         │ 返回总结
         ▼
┌─────────────────┐
│   评估是否充分   │
└────────┬────────┘
         │
     ┌───┴───┐
     │       │
    否       是
     │       │
     ▼       ▼
┌─────────┐  [接受]
│追问子代理│
└─────────┘
     │
     ▼
子代理回到源头
获取答案并返回

(最多 3 轮，防止无限循环)
```

### 实际例子

```
主编排器：
"子代理，查询用户认证模块的实现方式"

子代理：
"使用 JWT Token，存储在 localStorage"

主编排器（评估）：
"等等，这不够：
1. Token 过期怎么处理？
2. 安全性如何？
3. 是否支持刷新 Token？"

子代理（回去查询）：
"抱歉，补充信息：
1. Token 24 小时过期
2. 使用 HTTPS 传输
3. 支持 refresh Token"

主编排器（评估）：
"够了，接受"
```

## 解决方案：传递目标上下文

**是什么：** 发送子代理时，不仅发送"具体查询"，还发送"更广泛的目标"。

### 对比

| 方式 | 发送内容 | 结果 |
|------|----------|------|
| **只发查询** | "查询用户认证方式" | 子代理不知道为什么要查，总结可能遗漏关键信息 |
| **查询+目标** | "查询用户认证方式，因为我们需要支持高安全性场景" | 子代理知道优先关注安全性 |

### 实际例子

```markdown
# 不好的方式
"子代理，查询数据库查询的性能"

# 好的方式
"子代理，查询数据库查询的性能。我们的目标是支持每秒 10000 次查询，请重点关注性能优化方案"
```

## 解决方案：顺序阶段编排

**是什么：** 把复杂任务拆分成多个"阶段"，每个阶段用不同的子代理。

**通俗类比：** 就像餐厅的流水线：
1. **切配工** = 把食材切好
2. **炒菜师傅** = 把菜炒好
3. **摆盘师** = 把菜摆好
4. **质检员** = 检查菜品质量

### 5 阶段工作流

```
阶段 1：研究（Explore 代理）
  ↓
  - 收集上下文
  - 识别模式
  - 输出：research-summary.md

阶段 2：规划（Planner 代理）
  ↓
  - 读取 research-summary.md
  - 创建实现计划
  - 输出：plan.md

阶段 3：实现（TDD-Guide 代理）
  ↓
  - 读取 plan.md
  - 先写测试
  - 再写代码
  - 输出：代码变更

阶段 4：审查（Code-Reviewer 代理）
  ↓
  - 审查所有变更
  - 输出：review-comments.md

阶段 5：验证（Build-Error-Resolver 代理）
  ↓
  - 运行测试
  - 修复问题
  - 输出：完成或循环回去
```

### 关键规则

1. **每个代理只有 1 个明确的输入**
2. **每个代理只产生 1 个明确的输出**
3. **输出成为下一阶段的输入**
4. **代理之间用 `/clear` 清理上下文**
5. **中间输出保存到文件**（不只存在内存里）

### 为什么这样做？

| 优势 | 说明 |
|------|------|
| **职责明确** | 每个代理只做一件事，做好为止 |
| **可追溯** | 每个阶段的输出都有文件记录 |
| **容易调试** | 如果出问题，知道是哪个阶段的问题 |
| **可复用** | 每个代理可以在其他项目中复用 |

---

# 第七部分：代理抽象层级（Tierlist）

**是什么：** 把各种代理技巧按"易用性"和"效果"分级。

**通俗类比：** 就像电子游戏的"新手推荐"：
- Tier 1 = 简单但有效（推荐新手先学这些）
- Tier 2 = 复杂但强大（掌握基础后再学）

## Tier 1：直接增益（易于使用）

### 1. 子代理（Subagents）

**为什么好用：**
- 防止上下文腐烂
- 临时专业化
- 复杂度低

**类比：** 就像雇专科医生，比全科医生更专业，但不需要管理整个医院

### 2. 元提示（Metaprompting）

**是什么：** 花 3 分钟写一个好的提示词，完成 20 分钟的任务。

**类比：** 就像出发前先查地图，比迷路后找路快得多

### 3. 多问用户问题

**为什么好用：**
- 避免假设错误
- 一次做对
- 节省 token

**类比：** 就像装修前先问业主想要什么风格，比做完后再重装省事

## Tier 2：高技能门槛（难用好）

### 1. 长运行代理（Long-running agents）

**挑战：**
- 需要理解 15 分钟 vs 1.5 小时 vs 4 小时任务的权衡
- 需要反复调试
- 试错成本高

**类比：** 就像马拉松 vs 短跑，需要不同的策略和训练

### 2. 并行多代理（Parallel multi-agent）

**挑战：**
- 方差很高（有时很好，有时很差）
- 只在高度复杂或分割良好的任务上有效
- 合并变更的成本可能很高

**类比：** 就像 10 个厨师在一个厨房，配合不好反而更慢

**作者的建议：**
> "如果 2 个任务各需 10 分钟，但你花了任意时间在提示词上，或者更糟，在合并变更上，这是适得其反的"

### 3. 基于角色的多代理（Role-based multi-agent）

**挑战：**
- 模型进化太快，硬编码的启发式规则很快过时
- 难以测试

**类比：** 就像给演员写死剧本，但观众口味变了，剧本就不适用了

### 4. 计算机使用代理（Computer use agents）

**挑战：**
- 早期范式，需要很多调试
- 让模型做一年前根本没打算做的事

**类比：** 就像教猫做饭，理论可行，但实际很难

## 总结建议

**作者的结论：**

> "从 Tier 1 模式开始。只有掌握了基础并有真实需求时，才升级到 Tier 2。"

**类比：**
- **Tier 1** = 学会基本的开车（足够应付 90% 的场景）
- **Tier 2** = 学赛车漂移（只在特定场景有用）

**大多数人的误区：**
- 还没学会走，就想跑
- 追求"高级"技巧，忽略了"基础"技巧
- 结果：更复杂、更慢、更贵

---

# 第八部分：MCP 优化 - 释放上下文窗口

## 问题：MCP 吃上下文

**是什么：** 启用太多 MCP 会显著减少可用上下文。

**通俗类比：**
- **MCP** = 你的外部合作伙伴（翻译、装修、清洁等）
- 每个合作伙伴都要占用一点"办公室空间"
- 合作伙伴太多，你的工作空间就小了

## 解决方案1：MCP → CLI + Skills

**是什么：** 把 MCP 的功能转换成 CLI 命令 + 技能，减少上下文占用。

**通俗类比：**
- **用 MCP** = 合作伙伴天天坐在你办公室（占空间）
- **用 CLI + Skills** = 合作伙伴在家，你打电话叫他（不占空间）

### 例子：GitHub MCP

```bash
# 不推荐：启用 GitHub MCP
# （吃掉上下文）

# 推荐：创建 /gh-pr 命令
~/.claude/commands/gh-pr.md
```

**命令内容：**
```markdown
---
description: 创建 GitHub PR
command: |
  gh pr create \
    --title "$TITLE" \
    --body "$BODY" \
    --reviewer "$REVIEWER"
---
```

**使用：**
```bash
/gh-pr
# 等价于运行 gh pr create，但不占用 MCP 的上下文
```

### 例子：Supabase MCP

```bash
# 不推荐：启用 Supabase MCP
# （吃掉上下文）

# 推荐：创建技能
~/.claude/skills/supabase-query.md
```

**技能内容：**
```markdown
---
description: 查询 Supabase 数据库
instruction: |
  使用 Supabase CLI 查询数据库：
  1. supabase db remote commit
  2. supabase db remote branches
  3. supabase db remote diff
---
```

### 好处

| 方面 | MCP | CLI + Skills |
|------|-----|--------------|
| **上下文占用** | 高 | 低 |
| **Token 成本** | 高 | 低 |
| **灵活性** | 中等 | 高 |
| **维护成本** | 低 | 中等 |

## 解决方案2：延迟加载（Lazy Loading）

**是什么：** Claude Code 的新功能，只在需要时才加载 MCP。

**通俗类比：**
- **旧方式** = 所有合作伙伴一早就来办公室坐着
- **延迟加载** = 合作伙伴在家，你需要时才打电话叫他

### 好处

- 上下文窗口问题基本解决
- 但 token 成本问题还没完全解决

### 建议

```
延迟加载 + CLI + Skills = 最佳组合
```

**原因：**
1. 延迟加载解决了上下文窗口问题
2. CLI 方式解决了 token 成本问题
3. 技能提供了灵活性

---

# 第九部分：llms.txt 模式

**是什么：** 许多文档网站提供的 "llms.txt" 文件，是专门为 AI 优化的文档版本。

**通俗类比：**
- **普通文档** = 给人类看的说明书（有图片、广告、复杂格式）
- **llms.txt** = 给 AI 看的纯文本版（只保留核心信息，干净简洁）

### 如何使用

1. 访问文档网站
2. 在 URL 后加 `/llms.txt`

**例子：**
```
https://example.com/docs         → 普通文档
https://example.com/docs/llms.txt → AI 优化版
```

### 实际例子

```markdown
# 普通文档（HTML）
<!DOCTYPE html>
<html>
  <head>
    <title>API 文档</title>
    <style>...</style>
  </head>
  <body>
    <nav>...</nav>
    <aside>...</aside>
    <main>
      <h1>API 文档</h1>
      <img src="..." />
      <p>...</p>
    </main>
  </body>
</html>

# llms.txt（纯文本）
# API 文档

## 用户认证
POST /auth/login
参数：
- username: string
- password: string

返回：
{ token: string }

## 获取用户信息
GET /users/:id
Header: Authorization: Bearer {token}
```

**好处：**
- 直接喂给 Claude，不用"抓取网页"
- 更干净，没有噪音
- token 更省

---

# 第十部分：哲学 - 构建可重用模式

## 核心理念

**作者的观点：**

> "早期，我花时间构建可重用的工作流/模式。虽然构建起来很繁琐，但随着模型和代理工具的改进，这产生了疯狂的复合效应。"

## 什么值得投资？

| 投资 | 复合效应 |
|------|----------|
| **子代理** | 在每个项目中复用 |
| **技能** | 积累"经验库" |
| **命令** | 一次创建，永久使用 |
| **规划模式** | 每次项目启动更快 |
| **MCP 工具** | 一次配置，所有项目受益 |
| **上下文工程模式** | 跨模型迁移 |

### 为什么复合？

**类比：** 就像存钱
- 第 1 天：存 100 元 → 余额 100
- 第 10 天：存 100 元 → 余额 1000
- 第 100 天：存 100 元 → 余额 10000

**可重用模式的复合效应：**
- 第 1 个项目：创建 10 个技能，花了 2 小时
- 第 10 个项目：复用这 10 个技能，节省 2 小时
- 第 100 个项目：复用这 10 个技能，节省 2 小时

**总计：** 投资 2 小时，节省 200 小时

### 跨模型迁移

**关键洞察：**

> "最好的部分是，所有这些工作流都可以迁移到其他代理（如 Codex）。"

**类比：**
- 你学的开车技能，可以用在任何车上
- 你建的技能库，可以用在任何 AI 模型上

**结论：**

> "投资于模式 > 投资于特定模型技巧"

---

# 总结：5 条核心原则

## 1. 不要过度复杂化

**类比：** 做饭只需要必要的厨具，不需要买一堆用不上的小电器

**实践：**
- 从 Tier 1 技巧开始
- 只在真正需要时才用 Tier 2
- 简单 > 复杂

## 2. 记忆要持久化

**类比：** 每天下班写工作日记，第二天快速接上进度

**实践：**
- 使用会话日志模式
- 配置记忆持久化钩子
- 建立持续学习系统

## 3. Token 要精打细算

**类比：** 每一分钱都要花在刀刃上

**实践：**
- 智能选择模型（Haiku vs Sonnet vs Opus）
- 用更好的工具（mgrep vs grep）
- 模块化代码库
- 精简死代码

## 4. 验证要及时

**类比：** 每道菜做完立即尝味道，不要等端上桌才发现太咸

**实践：**
- 使用检查点验证或连续验证
- 及时发现问题，及时修复
- 不要让错误累积

## 5. 并行要适度

**类比：** 雇 3 个助理刚好，雇 10 个就是浪费

**实践：**
- 大多数时候 2-3 个实例就够了
- 用 Git Worktrees 避免冲突
- 主对话做代码变更，fork 做信息收集

---

# 最终类比：经营一家高效的公司

**把整个 Claude Code 生态想象成一家公司：**

1. **记忆系统** = 公司的知识库和文档系统
2. **Token 经济学** = 财务管理（控制成本）
3. **验证模式** = 质量控制部门
4. **并行工作流** = 项目管理和多团队协作
5. **子代理编排** = 组织架构和部门协作
6. **MCP 优化** = 外包策略（哪些自己做，哪些外包）
7. **可重用模式** = 企业文化和标准流程

**最终目标：**

> 像经营一家高效公司一样经营你的 Claude Code 工作流，让 AI 成为你的"超级助理团"，而不是一个总是需要你重新教导的健忘助手。

---

## 参考资源

- [Anthropic: Demystifying evals for AI agents](https://github.com/anthropics/anthropic-quickstarts/tree/main/cookbook/evals) (2026年1月)
- Anthropic: "Claude Code Best Practices" (2025年4月)
- Fireworks AI: "Eval Driven Development with Claude Code" (2025年8月)
- [YK: 32 Claude Code Tips](https://github.com/ykdojo/claude-code-tips) (2025年12月)
- Addy Osmani: "My LLM coding workflow going into 2026"
- Sub-Agent Context Negotiation
- Agent Abstractions Tierlist
- Compound Effects Philosophy
- RLanceMartin: Session Reflection Pattern
- Self-Improving Memory System

---

*来源：[@affaanmustafa 在 X/Twitter](https://x.com/affaanmustafa/status/2014040193557471352)*
*本文由文科生友好的比喻改编*
*配合《Claude Code 深度技巧》一起阅读效果更佳*
