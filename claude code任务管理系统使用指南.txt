Claude Code 全新任务管理系统深度解析与应用指南
1. 系统背景：破解“智能体失忆症” (Agent Amnesia)
在处理复杂的工程项目时，AI 编码智能体普遍面临**“智能体失忆症” (Agent Amnesia)** 的严峻挑战。
• 痛点定义与成因：由于上下文窗口（Context Window）的物理限制，当会话积压过多信息或因故障重启时，智能体往往会丢失当前的执行进度。开发者不得不手动将剩余任务记录在外部文件中并重新加载，这种“手动同步”极大地中断了开发流水线。
• 旧版会话内存的局限性：旧版 Claude Code 将待办事项存储在不稳定的会话内存（Session Memory）中。这意味着 /clear 命令或会话崩溃会导致任务列表彻底蒸发。
• 设计演进：从内存到持久化：新系统借鉴了开源库 Beads 的设计哲学，将任务状态从内存转移到本地文件系统。通过实现状态持久化 (State Persistence)，Claude 现在能够跨越多个会话甚至多个实例维持其工作目标，彻底解决了由于上下文溢出导致的执行中断。
2. 核心架构：分布式任务编排与依赖逻辑
新系统不仅仅是一个“待办清单”，它是一个具备分布式任务编排 (Distributed Task Orchestration) 能力的工程管理引擎。
2.1 本地存储与状态一致性
所有任务数据均持久化在项目根目录的 .claude/tasks 文件夹中。这种设计确保了任务状态不依赖于单一会话进程，即便是系统重启或跨设备同步（通过版本控制工具），开发进度依然有据可查。
2.2 任务依赖与“波次” (Waves) 执行逻辑
系统通过 Blocks（阻塞）与 Is Blocked By（受阻于）定义任务间的依赖关系。
• 依赖识别：系统能够自动分析任务优先级，并将其划分为不同的执行**“波次” (Waves)**。
• 并行逻辑：所有无活动依赖项（即零阻塞）的任务会被分配到 Wave 1 进行并行处理。这种基于依赖图的调度策略，确保了复杂工程流（如：先配置环境，再编写代码，最后测试）的严密执行顺序。
2.3 上下文隔离与代码完整性
借鉴“Ralph Wiggum”模式，系统允许通过子智能体 (Sub-agents) 隔离执行任务。
• 上下文优化：实测数据显示，使用子智能体并行模式的会话仅占用约 18% 的上下文窗口，而全部挤在主会话中执行则会占用高达 56%。
• 代码完整性：任务隔离不仅是为了节省空间，更核心的价值在于防止上下文污染 (Context Pollution)。每个子智能体在干净的环境中运行，有效避免了 AI 常见的合并冲突 (Merge Conflicts) 与可合并性问题 (Mergeability Problems)。
• 关键架构提醒：作为高级专家，必须指出一个潜在的“策应开销”：虽然子智能体拥有独立上下文，但主协调会话 (Orchestrator) 仍会持续接收各子智能体的输出汇总，因此主会话的上下文占用仍会缓慢增长。
3. 开发者工具箱：新增核心工具解析
系统为子智能体和主会话赋能了四项核心工具，赋予了智能体动态调整执行计划的自主权。
工具名称
核心功能描述
专家级应用场景
TaskCreate
初始化新任务并定义依赖项
子智能体在执行中发现新 Bug 时，可自主调用此工具创建修复任务。
TaskGet
检索特定任务的完整定义与元数据
校验者（Checker）使用此工具获取原始需求，作为验证的标准答案。
TaskUpdate
更新状态、进度或传递上下文信息
用于在子智能体之间传递关键变量或标记任务阶段性成果。
TaskList
检索全局任务清单及状态视图
跨会话同步时，用于防止多个实例重复启动同一个任务。
4. 多会话协同与“校验者” (Checker) 模式
新系统支持多个 Claude Code 实例实时共享同一个任务列表，实现了高效的协同工作模型。
4.1 实时广播机制
相较于传统的轮询（Polling）模式（往往伴随 30 秒以上的状态滞后），新系统实现了状态更新的即时广播。这有效规避了两个独立会话意外抢占执行同一个任务的风险。
4.2 实战进阶：Checker 模式工作流
通过配置一个独立的“监控会话”，可以建立一个健壮的自动化质检体系：
1. 双向共享：启动两个具有相同 task list ID 的会话。
2. 验证逻辑：配置监控会话每隔 5 秒调用 TaskList 检查已完成任务。
3. 闭环验证：一旦任务标记为完成，监控会话调用 TaskGet 获取需求详情，并派生一个校验子智能体。
4. 交叉模型验证 (Cross-model Validation)：高级用户可在校验会话中调用 Gemini CLI 或其他无头 CLI 工具，实现多模型间的交叉核验。如果发现缺陷，监控会话将通过 TaskCreate 将修复任务重新加入队列。
5. 配置指南：ID 持久化与协作作用域
默认情况下，task list ID 随会话 ID 变化，/clear 操作会导致逻辑上的关联丢失。要实现真正的生产级连续性，需按以下方式配置：
• 手动指定 ID：通过环境变量定义任务作用域： CLAUDE_CODE_TASK_LIST_ID=my_project_v1 claude
• 工程化持久化：在项目的 settings.json 中配置，确保所有参与该项目的开发者共享同一个协作作用域 (Scope of Collaboration)。
• 生命周期逻辑：系统在检测到所有任务全部标记为完成时，会自动清理 .claude/tasks 中的本地数据，保持项目目录整洁。
6. 专家建议与最佳实践
• 显式指令触发：系统并不总是自动启用子智能体模式。为了获得最佳的上下文隔离效果，请在 Prompt 中明确要求：“请使用独立的子智能体执行列表中的各项任务” (Execute each task in its own sub-agent)。
• 异常捕获：教育你的子智能体在遇到阻碍后续任务的未知 Bug 时，优先使用 TaskCreate 记录问题，而非强行合并错误的代码。
• 工具选择：虽然内置系统提供了无缝集成，但如果你需要极高程度的自定义（如特殊的 JSON 结构或外部 API 集成），原生的 Beads 库仍保留其灵活性优势。
• 监控开销平衡：在配置 Checker 模式时，建议根据项目规模调整检查频率，以平衡 API 调用成本与验证的实时性。